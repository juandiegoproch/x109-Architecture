1.1 Abstract
The x109 ISA is a ERISC (Extremely Reduced Instruction Set Computing) 16 bit instruction set capable of turing complete execution of programs. It provides 15 powerfull instructions that allow the logical and aritmetic manipulation of all registers, helping to make phisical implementation easy while not impeding the programmer. These instructions allow the loading of literal values from memory and the computation of addition and substraction as well as negation and conjunction of register values. Direct memory manipulation is archieved through register mapped memory, allowing for simple memory access.

1.2 Registers
The registers are discussed in further detail below:

Program Counter:
	The program counter holds the adress of the next instruction to be executed. It can be accesed and modified as any other register and this will modify the next instruction to be executed. It is incremented by one every cpu cycle.
	ID: 7
	Mnemonic: PC
	
Branch Pointer
	The Branch Pointer indicates the memory location to wich the PC will be set if a branch is called. It acts as a general purpose register
	ID: 6
	Mnemonic: BP

Memory Pointer:
	The Memory Pointer holds the adress of the memory visible through the Memory Data register mapped memory.
	ID:5
	Mnemonic MP
	
Register 0, Register 1 and Register 2
	General Purpose registers.
	Mnemonic: R0,R1,R2
	ID: 2,3,4

Memory Data
	The Memory Data register acts as a window to allow direct reading and writing of the memory at the adress pointed to by the Memory Pointer
	Mnemonic: MD
	ID: 1
	
Zero Register
	The Zero Register will allow write operations, though these have no effect on the value that is read, wich is allways zero.
	Mnemonic: ZR;
	ID: 0

1.3 Instructions
The 8 registers constitute most of the operands that the instructions can handle. These are discussed in detail below:

1.3.1 Register Value Manipulation Instructions (Opcode 1)

	Add:
		The add instruction adds together two registers, operand1 and operand2 and stores the result on the store register.
		Mnemonic: ADD STR,OP1, OP2;

	Subtract
		The subtract instruction performs an aritmetical negation in operand1 and then adds operand2, then stores the result in the store register.
		Mnmemonic: SUB STR,OP1,OP2;

	One's Complement Addition
		The one's complement addition computes the one's complement of operand1 and adds that to operand2, then stores the result in the store register.
		Mnemonic: NSM STR,OP1,OP2;

	Move 
		The move instruction copies the value from one register (operand2) to another (str).
		Mnemonic MOV STR,OP2; //OP1 is allways ZR
	Logical Or
		The Logical Or instruction performs a bitwise logical or between operand1 and operand2 and stores the result on the store register.
		Mnemonic LOR STR,OP1,OP2;
	Logical Negation
		The Logical Negation instruction performs bitwise negation of operand1, then saves the result at store register.
		Mnemonic NOT STR,OP1; //OP2 is allways ZR

	Add and Increment
		 The add instruction adds together two registers, operand1 and operand2, increments the result and stores the result on the store register.
		 Mnemonic: ADI STR,OP1,OP2;
	Increment
		The increment isntruction increments operand2, then stores it at the store register
		Mnemonic: INC STR,OP2; // OP1 is allways ZR
	Decrement
		The increment isntruction increments operand2, then stores it at the store register
		Mnemonic: DEC STR,OP2;// OP1 is allways ZR
	1.3.2 Constant Computation
		The x109 ALU has the ability to compute two usefull values, wich allows for potential savings on program length if used. These are executed as cpu instructions, but behave as if loading a constant to a register.
		Mnemonic: CON 0xHHHH ST;
		Allowed values: 0x0000, 0xFFFF;
		
	1.3.3 Load Instructions
	
		Load Less Significant Byte
			This loads the immediate 8bit literal value into the LSB of the specified register;
			Mnemonic: LDL STR,0xHH;
		Load Most Significant Byte
			This loads the immediate 8bit literal value into the MSB of the specified register;
			Mnemonic: LDM STR,0xHH;
	1.3.4 Branch Instructions
		
		Unconditional Branch
			Sets the PC to JR, equivalent to MOV PC,JR;
			Mnemonic: BRN;
		Branch if Negative
			Performs a Subtract operation and if the result's 16th bit is true, moves JR to PC
			Mnemonic: BNE OP1,OP2;
		Branch if Negative
			Performs a Subtract operation and if the result is 0, moves JR to PC
			Mnemonic: BEQ OP1,OP2;
		Branch if Negative or Zero
			Performs a Subtract operation and if the result's 16th bit is true or the result is zero, moves JR to PC
			Mnemonic: BLE OP1,OP2;
		
